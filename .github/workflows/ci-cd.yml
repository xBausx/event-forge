name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch: # Allows manual triggering of the workflow

# Global environment variables - Region normalized to us-east-1
env:
  AWS_REGION: "us-east-1"
  PYTHON_VERSION: "3.12"
  NODE_VERSION: "20.x"
  TERRAFORM_VERSION: "1.6.0"

permissions:
  contents: write

jobs:
  # ====================================================================================
  # LINT & VALIDATE: Runs on every PR and push to main.
  # ====================================================================================
  lint:
    name: "Lint & Validate"
    runs-on: ubuntu-latest
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: "Set up Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: "Set up Terraform"
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # install tflint so the pre-commit hook can run it
      - name: "Set up TFLint"
        uses: terraform-linters/setup-tflint@v4

      # format *.tf files first so the terraform_fmt hook doesn't need to modify anything
      - name: Terraform fmt (CI pre-step)
        shell: bash
        working-directory: infra/terraform
        run: terraform fmt -recursive

      - name: "Auto-commit Terraform fmt changes"
        if: github.event_name == 'push'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(terraform): fmt via CI"
          branch: ${{ github.ref_name }}
          file_pattern: infra/terraform/**/*.tf

      - name: "Install pre-commit"
        run: pip install pre-commit

      - name: "Run linters via Makefile"
        run: make lint

  # ====================================================================================
  # DEPLOY: This job builds the application code and then deploys the infrastructure.
  # ====================================================================================
  deploy:
    name: "Build & Deploy to AWS"
    needs: lint
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ (github.ref == 'refs/heads/main' && 'dev') || 'none' }}

    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: "Set up Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: "Configure AWS Credentials (Access Keys)"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "Build Python Lambdas with Dependencies"
        run: |
          set -e
          echo "Building Python Lambda packages..."
          for fn in read_sheet generate_poster send_report; do
            echo "--- Packaging $fn ---"
            pushd src/lambdas/$fn
            # Vendor dependencies into the function directory
            python3 -m pip install -r requirements.txt -t .
            # Copy the shared common code
            if [ ! -d "src" ]; then mkdir src; fi
            cp -r ../../common src/common
            # Optional: Clean up to reduce zip size
            find . -type d -name "__pycache__" -exec rm -rf {} +
            popd
          done
          echo "All Python Lambdas packaged successfully."

      - name: "Build Orchestration Code"
        run: |
          echo "Building TypeScript orchestration code..."
          pushd src/orchestration
          npm ci
          npm run build
          popd
          echo "Orchestration code built successfully."

      - name: "Set up Terraform"
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: "Sync Inngest signing key into Secrets Manager (DEV)"
        if: github.ref == 'refs/heads/main'
        env:
          INNGEST_SIGNING_KEY_DEV: ${{ secrets.INNGEST_SIGNING_KEY_DEV }}
          REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail

          if [ -z "${INNGEST_SIGNING_KEY_DEV:-}" ]; then
            echo "ERROR: GitHub secret INNGEST_SIGNING_KEY_DEV is not set."
            echo "Generate a 64-hex string and add it under Repo Settings → Secrets → Actions."
            exit 1
          fi

          SECRET_NAME="event-forge/inngest-signing-key-dev"

          if ! aws secretsmanager describe-secret --secret-id "$SECRET_NAME" --region "$REGION" >/dev/null 2>&1; then
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --secret-string "$INNGEST_SIGNING_KEY_DEV" \
              --region "$REGION"
            echo "Created $SECRET_NAME in $REGION"
          else
            # ensure it has a current value
            if ! aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" --region "$REGION" >/dev/null 2>&1; then
              aws secretsmanager put-secret-value \
                --secret-id "$SECRET_NAME" \
                --secret-string "$INNGEST_SIGNING_KEY_DEV" \
                --region "$REGION"
              echo "Set value for $SECRET_NAME"
            else
              echo "$SECRET_NAME already has a value; leaving as is."
            fi
          fi
      
      # Terraform Apply must run *after* the build steps, so the zip files exist.
      - name: "Terraform Apply (dev)"
        if: github.ref == 'refs/heads/main'
        run: make tf-apply env=dev
